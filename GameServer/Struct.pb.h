// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Struct.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Struct_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Struct_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Struct_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Struct_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Struct_2eproto;
namespace Protocol {
class AddPlayer;
struct AddPlayerDefaultTypeInternal;
extern AddPlayerDefaultTypeInternal _AddPlayer_default_instance_;
class EquipmentItem;
struct EquipmentItemDefaultTypeInternal;
extern EquipmentItemDefaultTypeInternal _EquipmentItem_default_instance_;
class GoldRanking;
struct GoldRankingDefaultTypeInternal;
extern GoldRankingDefaultTypeInternal _GoldRanking_default_instance_;
class InventorySlot;
struct InventorySlotDefaultTypeInternal;
extern InventorySlotDefaultTypeInternal _InventorySlot_default_instance_;
class Mess;
struct MessDefaultTypeInternal;
extern MessDefaultTypeInternal _Mess_default_instance_;
class Move;
struct MoveDefaultTypeInternal;
extern MoveDefaultTypeInternal _Move_default_instance_;
class Player;
struct PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class Stat;
struct StatDefaultTypeInternal;
extern StatDefaultTypeInternal _Stat_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::AddPlayer* Arena::CreateMaybeMessage<::Protocol::AddPlayer>(Arena*);
template<> ::Protocol::EquipmentItem* Arena::CreateMaybeMessage<::Protocol::EquipmentItem>(Arena*);
template<> ::Protocol::GoldRanking* Arena::CreateMaybeMessage<::Protocol::GoldRanking>(Arena*);
template<> ::Protocol::InventorySlot* Arena::CreateMaybeMessage<::Protocol::InventorySlot>(Arena*);
template<> ::Protocol::Mess* Arena::CreateMaybeMessage<::Protocol::Mess>(Arena*);
template<> ::Protocol::Move* Arena::CreateMaybeMessage<::Protocol::Move>(Arena*);
template<> ::Protocol::Player* Arena::CreateMaybeMessage<::Protocol::Player>(Arena*);
template<> ::Protocol::Stat* Arena::CreateMaybeMessage<::Protocol::Stat>(Arena*);
template<> ::Protocol::User* Arena::CreateMaybeMessage<::Protocol::User>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.Player) */ {
 public:
  inline Player() : Player(nullptr) {}
  ~Player() override;
  explicit constexpr Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Player* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Player& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Player& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.Player";
  }
  protected:
  explicit Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayertypeFieldNumber = 1,
    kNameFieldNumber = 3,
    kIdFieldNumber = 2,
    kXFieldNumber = 4,
    kYFieldNumber = 5,
    kLevelFieldNumber = 6,
    kHpFieldNumber = 7,
    kMaxhpFieldNumber = 8,
    kMpFieldNumber = 9,
    kMaxmpFieldNumber = 10,
    kExpFieldNumber = 11,
    kMaxexpFieldNumber = 12,
    kGoldFieldNumber = 13,
  };
  // repeated .Protocol.PlayerType playertype = 1;
  int playertype_size() const;
  private:
  int _internal_playertype_size() const;
  public:
  void clear_playertype();
  private:
  ::Protocol::PlayerType _internal_playertype(int index) const;
  void _internal_add_playertype(::Protocol::PlayerType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_playertype();
  public:
  ::Protocol::PlayerType playertype(int index) const;
  void set_playertype(int index, ::Protocol::PlayerType value);
  void add_playertype(::Protocol::PlayerType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& playertype() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_playertype();

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 id = 2;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 x = 4;
  void clear_x();
  uint64_t x() const;
  void set_x(uint64_t value);
  private:
  uint64_t _internal_x() const;
  void _internal_set_x(uint64_t value);
  public:

  // uint64 y = 5;
  void clear_y();
  uint64_t y() const;
  void set_y(uint64_t value);
  private:
  uint64_t _internal_y() const;
  void _internal_set_y(uint64_t value);
  public:

  // uint64 level = 6;
  void clear_level();
  uint64_t level() const;
  void set_level(uint64_t value);
  private:
  uint64_t _internal_level() const;
  void _internal_set_level(uint64_t value);
  public:

  // uint64 hp = 7;
  void clear_hp();
  uint64_t hp() const;
  void set_hp(uint64_t value);
  private:
  uint64_t _internal_hp() const;
  void _internal_set_hp(uint64_t value);
  public:

  // uint64 maxhp = 8;
  void clear_maxhp();
  uint64_t maxhp() const;
  void set_maxhp(uint64_t value);
  private:
  uint64_t _internal_maxhp() const;
  void _internal_set_maxhp(uint64_t value);
  public:

  // uint64 mp = 9;
  void clear_mp();
  uint64_t mp() const;
  void set_mp(uint64_t value);
  private:
  uint64_t _internal_mp() const;
  void _internal_set_mp(uint64_t value);
  public:

  // uint64 maxmp = 10;
  void clear_maxmp();
  uint64_t maxmp() const;
  void set_maxmp(uint64_t value);
  private:
  uint64_t _internal_maxmp() const;
  void _internal_set_maxmp(uint64_t value);
  public:

  // uint64 exp = 11;
  void clear_exp();
  uint64_t exp() const;
  void set_exp(uint64_t value);
  private:
  uint64_t _internal_exp() const;
  void _internal_set_exp(uint64_t value);
  public:

  // uint64 maxexp = 12;
  void clear_maxexp();
  uint64_t maxexp() const;
  void set_maxexp(uint64_t value);
  private:
  uint64_t _internal_maxexp() const;
  void _internal_set_maxexp(uint64_t value);
  public:

  // uint64 gold = 13;
  void clear_gold();
  uint64_t gold() const;
  void set_gold(uint64_t value);
  private:
  uint64_t _internal_gold() const;
  void _internal_set_gold(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> playertype_;
  mutable std::atomic<int> _playertype_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint64_t id_;
  uint64_t x_;
  uint64_t y_;
  uint64_t level_;
  uint64_t hp_;
  uint64_t maxhp_;
  uint64_t mp_;
  uint64_t maxmp_;
  uint64_t exp_;
  uint64_t maxexp_;
  uint64_t gold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit constexpr User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const User& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayertypeFieldNumber = 1,
    kNameFieldNumber = 3,
    kIdFieldNumber = 2,
    kXFieldNumber = 4,
    kYFieldNumber = 5,
    kGoldFieldNumber = 6,
  };
  // repeated .Protocol.PlayerType playertype = 1;
  int playertype_size() const;
  private:
  int _internal_playertype_size() const;
  public:
  void clear_playertype();
  private:
  ::Protocol::PlayerType _internal_playertype(int index) const;
  void _internal_add_playertype(::Protocol::PlayerType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_playertype();
  public:
  ::Protocol::PlayerType playertype(int index) const;
  void set_playertype(int index, ::Protocol::PlayerType value);
  void add_playertype(::Protocol::PlayerType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& playertype() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_playertype();

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 id = 2;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 x = 4;
  void clear_x();
  uint64_t x() const;
  void set_x(uint64_t value);
  private:
  uint64_t _internal_x() const;
  void _internal_set_x(uint64_t value);
  public:

  // uint64 y = 5;
  void clear_y();
  uint64_t y() const;
  void set_y(uint64_t value);
  private:
  uint64_t _internal_y() const;
  void _internal_set_y(uint64_t value);
  public:

  // uint64 gold = 6;
  void clear_gold();
  uint64_t gold() const;
  void set_gold(uint64_t value);
  private:
  uint64_t _internal_gold() const;
  void _internal_set_gold(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> playertype_;
  mutable std::atomic<int> _playertype_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint64_t id_;
  uint64_t x_;
  uint64_t y_;
  uint64_t gold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class Stat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.Stat) */ {
 public:
  inline Stat() : Stat(nullptr) {}
  ~Stat() override;
  explicit constexpr Stat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stat(const Stat& from);
  Stat(Stat&& from) noexcept
    : Stat() {
    *this = ::std::move(from);
  }

  inline Stat& operator=(const Stat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stat& operator=(Stat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stat* internal_default_instance() {
    return reinterpret_cast<const Stat*>(
               &_Stat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Stat& a, Stat& b) {
    a.Swap(&b);
  }
  inline void Swap(Stat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Stat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Stat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.Stat";
  }
  protected:
  explicit Stat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 1,
    kExpFieldNumber = 2,
    kMaxexpFieldNumber = 3,
    kHpFieldNumber = 4,
    kMaxhpFieldNumber = 5,
    kMpFieldNumber = 6,
    kMaxmpFieldNumber = 7,
    kAttackPowerFieldNumber = 8,
    kDefensePowerFieldNumber = 9,
    kMagicPowerFieldNumber = 10,
    kStrenthFieldNumber = 11,
  };
  // uint64 level = 1;
  void clear_level();
  uint64_t level() const;
  void set_level(uint64_t value);
  private:
  uint64_t _internal_level() const;
  void _internal_set_level(uint64_t value);
  public:

  // uint64 exp = 2;
  void clear_exp();
  uint64_t exp() const;
  void set_exp(uint64_t value);
  private:
  uint64_t _internal_exp() const;
  void _internal_set_exp(uint64_t value);
  public:

  // uint64 maxexp = 3;
  void clear_maxexp();
  uint64_t maxexp() const;
  void set_maxexp(uint64_t value);
  private:
  uint64_t _internal_maxexp() const;
  void _internal_set_maxexp(uint64_t value);
  public:

  // uint64 hp = 4;
  void clear_hp();
  uint64_t hp() const;
  void set_hp(uint64_t value);
  private:
  uint64_t _internal_hp() const;
  void _internal_set_hp(uint64_t value);
  public:

  // uint64 maxhp = 5;
  void clear_maxhp();
  uint64_t maxhp() const;
  void set_maxhp(uint64_t value);
  private:
  uint64_t _internal_maxhp() const;
  void _internal_set_maxhp(uint64_t value);
  public:

  // uint64 mp = 6;
  void clear_mp();
  uint64_t mp() const;
  void set_mp(uint64_t value);
  private:
  uint64_t _internal_mp() const;
  void _internal_set_mp(uint64_t value);
  public:

  // uint64 maxmp = 7;
  void clear_maxmp();
  uint64_t maxmp() const;
  void set_maxmp(uint64_t value);
  private:
  uint64_t _internal_maxmp() const;
  void _internal_set_maxmp(uint64_t value);
  public:

  // uint64 attackPower = 8;
  void clear_attackpower();
  uint64_t attackpower() const;
  void set_attackpower(uint64_t value);
  private:
  uint64_t _internal_attackpower() const;
  void _internal_set_attackpower(uint64_t value);
  public:

  // uint64 defensePower = 9;
  void clear_defensepower();
  uint64_t defensepower() const;
  void set_defensepower(uint64_t value);
  private:
  uint64_t _internal_defensepower() const;
  void _internal_set_defensepower(uint64_t value);
  public:

  // uint64 magicPower = 10;
  void clear_magicpower();
  uint64_t magicpower() const;
  void set_magicpower(uint64_t value);
  private:
  uint64_t _internal_magicpower() const;
  void _internal_set_magicpower(uint64_t value);
  public:

  // uint64 strenth = 11;
  void clear_strenth();
  uint64_t strenth() const;
  void set_strenth(uint64_t value);
  private:
  uint64_t _internal_strenth() const;
  void _internal_set_strenth(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.Stat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t level_;
  uint64_t exp_;
  uint64_t maxexp_;
  uint64_t hp_;
  uint64_t maxhp_;
  uint64_t mp_;
  uint64_t maxmp_;
  uint64_t attackpower_;
  uint64_t defensepower_;
  uint64_t magicpower_;
  uint64_t strenth_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class InventorySlot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.InventorySlot) */ {
 public:
  inline InventorySlot() : InventorySlot(nullptr) {}
  ~InventorySlot() override;
  explicit constexpr InventorySlot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InventorySlot(const InventorySlot& from);
  InventorySlot(InventorySlot&& from) noexcept
    : InventorySlot() {
    *this = ::std::move(from);
  }

  inline InventorySlot& operator=(const InventorySlot& from) {
    CopyFrom(from);
    return *this;
  }
  inline InventorySlot& operator=(InventorySlot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InventorySlot& default_instance() {
    return *internal_default_instance();
  }
  static inline const InventorySlot* internal_default_instance() {
    return reinterpret_cast<const InventorySlot*>(
               &_InventorySlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InventorySlot& a, InventorySlot& b) {
    a.Swap(&b);
  }
  inline void Swap(InventorySlot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InventorySlot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InventorySlot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InventorySlot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InventorySlot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InventorySlot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InventorySlot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.InventorySlot";
  }
  protected:
  explicit InventorySlot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 1,
    kQuantityFieldNumber = 2,
    kInvSlotIndexFieldNumber = 4,
    kTabTypeFieldNumber = 3,
  };
  // uint64 item_id = 1;
  void clear_item_id();
  uint64_t item_id() const;
  void set_item_id(uint64_t value);
  private:
  uint64_t _internal_item_id() const;
  void _internal_set_item_id(uint64_t value);
  public:

  // uint64 quantity = 2;
  void clear_quantity();
  uint64_t quantity() const;
  void set_quantity(uint64_t value);
  private:
  uint64_t _internal_quantity() const;
  void _internal_set_quantity(uint64_t value);
  public:

  // uint64 inv_slot_index = 4;
  void clear_inv_slot_index();
  uint64_t inv_slot_index() const;
  void set_inv_slot_index(uint64_t value);
  private:
  uint64_t _internal_inv_slot_index() const;
  void _internal_set_inv_slot_index(uint64_t value);
  public:

  // .Protocol.InventoryTab tab_type = 3;
  void clear_tab_type();
  ::Protocol::InventoryTab tab_type() const;
  void set_tab_type(::Protocol::InventoryTab value);
  private:
  ::Protocol::InventoryTab _internal_tab_type() const;
  void _internal_set_tab_type(::Protocol::InventoryTab value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.InventorySlot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t item_id_;
  uint64_t quantity_;
  uint64_t inv_slot_index_;
  int tab_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class EquipmentItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.EquipmentItem) */ {
 public:
  inline EquipmentItem() : EquipmentItem(nullptr) {}
  ~EquipmentItem() override;
  explicit constexpr EquipmentItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EquipmentItem(const EquipmentItem& from);
  EquipmentItem(EquipmentItem&& from) noexcept
    : EquipmentItem() {
    *this = ::std::move(from);
  }

  inline EquipmentItem& operator=(const EquipmentItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline EquipmentItem& operator=(EquipmentItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EquipmentItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const EquipmentItem* internal_default_instance() {
    return reinterpret_cast<const EquipmentItem*>(
               &_EquipmentItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EquipmentItem& a, EquipmentItem& b) {
    a.Swap(&b);
  }
  inline void Swap(EquipmentItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EquipmentItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EquipmentItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EquipmentItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EquipmentItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EquipmentItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EquipmentItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.EquipmentItem";
  }
  protected:
  explicit EquipmentItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemIdFieldNumber = 2,
    kEqSlotFieldNumber = 1,
  };
  // uint64 item_id = 2;
  void clear_item_id();
  uint64_t item_id() const;
  void set_item_id(uint64_t value);
  private:
  uint64_t _internal_item_id() const;
  void _internal_set_item_id(uint64_t value);
  public:

  // .Protocol.EquipmentSlot eq_slot = 1;
  void clear_eq_slot();
  ::Protocol::EquipmentSlot eq_slot() const;
  void set_eq_slot(::Protocol::EquipmentSlot value);
  private:
  ::Protocol::EquipmentSlot _internal_eq_slot() const;
  void _internal_set_eq_slot(::Protocol::EquipmentSlot value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.EquipmentItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t item_id_;
  int eq_slot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class AddPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.AddPlayer) */ {
 public:
  inline AddPlayer() : AddPlayer(nullptr) {}
  ~AddPlayer() override;
  explicit constexpr AddPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddPlayer(const AddPlayer& from);
  AddPlayer(AddPlayer&& from) noexcept
    : AddPlayer() {
    *this = ::std::move(from);
  }

  inline AddPlayer& operator=(const AddPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddPlayer& operator=(AddPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddPlayer* internal_default_instance() {
    return reinterpret_cast<const AddPlayer*>(
               &_AddPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AddPlayer& a, AddPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(AddPlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddPlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddPlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.AddPlayer";
  }
  protected:
  explicit AddPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayertypeFieldNumber = 1,
    kNameFieldNumber = 3,
    kIdFieldNumber = 2,
    kXFieldNumber = 4,
    kYFieldNumber = 5,
  };
  // repeated .Protocol.PlayerType playertype = 1;
  int playertype_size() const;
  private:
  int _internal_playertype_size() const;
  public:
  void clear_playertype();
  private:
  ::Protocol::PlayerType _internal_playertype(int index) const;
  void _internal_add_playertype(::Protocol::PlayerType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_playertype();
  public:
  ::Protocol::PlayerType playertype(int index) const;
  void set_playertype(int index, ::Protocol::PlayerType value);
  void add_playertype(::Protocol::PlayerType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& playertype() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_playertype();

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 id = 2;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 x = 4;
  void clear_x();
  uint64_t x() const;
  void set_x(uint64_t value);
  private:
  uint64_t _internal_x() const;
  void _internal_set_x(uint64_t value);
  public:

  // uint64 y = 5;
  void clear_y();
  uint64_t y() const;
  void set_y(uint64_t value);
  private:
  uint64_t _internal_y() const;
  void _internal_set_y(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.AddPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> playertype_;
  mutable std::atomic<int> _playertype_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint64_t id_;
  uint64_t x_;
  uint64_t y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class Move final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.Move) */ {
 public:
  inline Move() : Move(nullptr) {}
  ~Move() override;
  explicit constexpr Move(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Move(const Move& from);
  Move(Move&& from) noexcept
    : Move() {
    *this = ::std::move(from);
  }

  inline Move& operator=(const Move& from) {
    CopyFrom(from);
    return *this;
  }
  inline Move& operator=(Move&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Move& default_instance() {
    return *internal_default_instance();
  }
  static inline const Move* internal_default_instance() {
    return reinterpret_cast<const Move*>(
               &_Move_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Move& a, Move& b) {
    a.Swap(&b);
  }
  inline void Swap(Move* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Move* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Move* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Move>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Move& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Move& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Move* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.Move";
  }
  protected:
  explicit Move(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kMoveTimeFieldNumber = 4,
  };
  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 x = 2;
  void clear_x();
  uint64_t x() const;
  void set_x(uint64_t value);
  private:
  uint64_t _internal_x() const;
  void _internal_set_x(uint64_t value);
  public:

  // uint64 y = 3;
  void clear_y();
  uint64_t y() const;
  void set_y(uint64_t value);
  private:
  uint64_t _internal_y() const;
  void _internal_set_y(uint64_t value);
  public:

  // int64 move_time = 4;
  void clear_move_time();
  int64_t move_time() const;
  void set_move_time(int64_t value);
  private:
  int64_t _internal_move_time() const;
  void _internal_set_move_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.Move)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t id_;
  uint64_t x_;
  uint64_t y_;
  int64_t move_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class Mess final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.Mess) */ {
 public:
  inline Mess() : Mess(nullptr) {}
  ~Mess() override;
  explicit constexpr Mess(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Mess(const Mess& from);
  Mess(Mess&& from) noexcept
    : Mess() {
    *this = ::std::move(from);
  }

  inline Mess& operator=(const Mess& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mess& operator=(Mess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mess& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mess* internal_default_instance() {
    return reinterpret_cast<const Mess*>(
               &_Mess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Mess& a, Mess& b) {
    a.Swap(&b);
  }
  inline void Swap(Mess* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mess>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Mess& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Mess& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mess* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.Mess";
  }
  protected:
  explicit Mess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string mess = 2;
  void clear_mess();
  const std::string& mess() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mess(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mess();
  PROTOBUF_NODISCARD std::string* release_mess();
  void set_allocated_mess(std::string* mess);
  private:
  const std::string& _internal_mess() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mess(const std::string& value);
  std::string* _internal_mutable_mess();
  public:

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.Mess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mess_;
  uint64_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class GoldRanking final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.GoldRanking) */ {
 public:
  inline GoldRanking() : GoldRanking(nullptr) {}
  ~GoldRanking() override;
  explicit constexpr GoldRanking(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GoldRanking(const GoldRanking& from);
  GoldRanking(GoldRanking&& from) noexcept
    : GoldRanking() {
    *this = ::std::move(from);
  }

  inline GoldRanking& operator=(const GoldRanking& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoldRanking& operator=(GoldRanking&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoldRanking& default_instance() {
    return *internal_default_instance();
  }
  static inline const GoldRanking* internal_default_instance() {
    return reinterpret_cast<const GoldRanking*>(
               &_GoldRanking_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GoldRanking& a, GoldRanking& b) {
    a.Swap(&b);
  }
  inline void Swap(GoldRanking* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoldRanking* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoldRanking* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GoldRanking>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GoldRanking& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GoldRanking& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GoldRanking* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.GoldRanking";
  }
  protected:
  explicit GoldRanking(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kGoldFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint64 gold = 2;
  void clear_gold();
  uint64_t gold() const;
  void set_gold(uint64_t value);
  private:
  uint64_t _internal_gold() const;
  void _internal_set_gold(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.GoldRanking)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint64_t gold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Player

// repeated .Protocol.PlayerType playertype = 1;
inline int Player::_internal_playertype_size() const {
  return playertype_.size();
}
inline int Player::playertype_size() const {
  return _internal_playertype_size();
}
inline void Player::clear_playertype() {
  playertype_.Clear();
}
inline ::Protocol::PlayerType Player::_internal_playertype(int index) const {
  return static_cast< ::Protocol::PlayerType >(playertype_.Get(index));
}
inline ::Protocol::PlayerType Player::playertype(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.Player.playertype)
  return _internal_playertype(index);
}
inline void Player::set_playertype(int index, ::Protocol::PlayerType value) {
  playertype_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.Player.playertype)
}
inline void Player::_internal_add_playertype(::Protocol::PlayerType value) {
  playertype_.Add(value);
}
inline void Player::add_playertype(::Protocol::PlayerType value) {
  _internal_add_playertype(value);
  // @@protoc_insertion_point(field_add:Protocol.Player.playertype)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
Player::playertype() const {
  // @@protoc_insertion_point(field_list:Protocol.Player.playertype)
  return playertype_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Player::_internal_mutable_playertype() {
  return &playertype_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
Player::mutable_playertype() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.Player.playertype)
  return _internal_mutable_playertype();
}

// uint64 id = 2;
inline void Player::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t Player::_internal_id() const {
  return id_;
}
inline uint64_t Player::id() const {
  // @@protoc_insertion_point(field_get:Protocol.Player.id)
  return _internal_id();
}
inline void Player::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void Player::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.Player.id)
}

// string name = 3;
inline void Player::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Player::name() const {
  // @@protoc_insertion_point(field_get:Protocol.Player.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Player::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.Player.name)
}
inline std::string* Player::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.Player.name)
  return _s;
}
inline const std::string& Player::_internal_name() const {
  return name_.Get();
}
inline void Player::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Player::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Player::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.Player.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Player::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.Player.name)
}

// uint64 x = 4;
inline void Player::clear_x() {
  x_ = uint64_t{0u};
}
inline uint64_t Player::_internal_x() const {
  return x_;
}
inline uint64_t Player::x() const {
  // @@protoc_insertion_point(field_get:Protocol.Player.x)
  return _internal_x();
}
inline void Player::_internal_set_x(uint64_t value) {
  
  x_ = value;
}
inline void Player::set_x(uint64_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.Player.x)
}

// uint64 y = 5;
inline void Player::clear_y() {
  y_ = uint64_t{0u};
}
inline uint64_t Player::_internal_y() const {
  return y_;
}
inline uint64_t Player::y() const {
  // @@protoc_insertion_point(field_get:Protocol.Player.y)
  return _internal_y();
}
inline void Player::_internal_set_y(uint64_t value) {
  
  y_ = value;
}
inline void Player::set_y(uint64_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.Player.y)
}

// uint64 level = 6;
inline void Player::clear_level() {
  level_ = uint64_t{0u};
}
inline uint64_t Player::_internal_level() const {
  return level_;
}
inline uint64_t Player::level() const {
  // @@protoc_insertion_point(field_get:Protocol.Player.level)
  return _internal_level();
}
inline void Player::_internal_set_level(uint64_t value) {
  
  level_ = value;
}
inline void Player::set_level(uint64_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Protocol.Player.level)
}

// uint64 hp = 7;
inline void Player::clear_hp() {
  hp_ = uint64_t{0u};
}
inline uint64_t Player::_internal_hp() const {
  return hp_;
}
inline uint64_t Player::hp() const {
  // @@protoc_insertion_point(field_get:Protocol.Player.hp)
  return _internal_hp();
}
inline void Player::_internal_set_hp(uint64_t value) {
  
  hp_ = value;
}
inline void Player::set_hp(uint64_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:Protocol.Player.hp)
}

// uint64 maxhp = 8;
inline void Player::clear_maxhp() {
  maxhp_ = uint64_t{0u};
}
inline uint64_t Player::_internal_maxhp() const {
  return maxhp_;
}
inline uint64_t Player::maxhp() const {
  // @@protoc_insertion_point(field_get:Protocol.Player.maxhp)
  return _internal_maxhp();
}
inline void Player::_internal_set_maxhp(uint64_t value) {
  
  maxhp_ = value;
}
inline void Player::set_maxhp(uint64_t value) {
  _internal_set_maxhp(value);
  // @@protoc_insertion_point(field_set:Protocol.Player.maxhp)
}

// uint64 mp = 9;
inline void Player::clear_mp() {
  mp_ = uint64_t{0u};
}
inline uint64_t Player::_internal_mp() const {
  return mp_;
}
inline uint64_t Player::mp() const {
  // @@protoc_insertion_point(field_get:Protocol.Player.mp)
  return _internal_mp();
}
inline void Player::_internal_set_mp(uint64_t value) {
  
  mp_ = value;
}
inline void Player::set_mp(uint64_t value) {
  _internal_set_mp(value);
  // @@protoc_insertion_point(field_set:Protocol.Player.mp)
}

// uint64 maxmp = 10;
inline void Player::clear_maxmp() {
  maxmp_ = uint64_t{0u};
}
inline uint64_t Player::_internal_maxmp() const {
  return maxmp_;
}
inline uint64_t Player::maxmp() const {
  // @@protoc_insertion_point(field_get:Protocol.Player.maxmp)
  return _internal_maxmp();
}
inline void Player::_internal_set_maxmp(uint64_t value) {
  
  maxmp_ = value;
}
inline void Player::set_maxmp(uint64_t value) {
  _internal_set_maxmp(value);
  // @@protoc_insertion_point(field_set:Protocol.Player.maxmp)
}

// uint64 exp = 11;
inline void Player::clear_exp() {
  exp_ = uint64_t{0u};
}
inline uint64_t Player::_internal_exp() const {
  return exp_;
}
inline uint64_t Player::exp() const {
  // @@protoc_insertion_point(field_get:Protocol.Player.exp)
  return _internal_exp();
}
inline void Player::_internal_set_exp(uint64_t value) {
  
  exp_ = value;
}
inline void Player::set_exp(uint64_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:Protocol.Player.exp)
}

// uint64 maxexp = 12;
inline void Player::clear_maxexp() {
  maxexp_ = uint64_t{0u};
}
inline uint64_t Player::_internal_maxexp() const {
  return maxexp_;
}
inline uint64_t Player::maxexp() const {
  // @@protoc_insertion_point(field_get:Protocol.Player.maxexp)
  return _internal_maxexp();
}
inline void Player::_internal_set_maxexp(uint64_t value) {
  
  maxexp_ = value;
}
inline void Player::set_maxexp(uint64_t value) {
  _internal_set_maxexp(value);
  // @@protoc_insertion_point(field_set:Protocol.Player.maxexp)
}

// uint64 gold = 13;
inline void Player::clear_gold() {
  gold_ = uint64_t{0u};
}
inline uint64_t Player::_internal_gold() const {
  return gold_;
}
inline uint64_t Player::gold() const {
  // @@protoc_insertion_point(field_get:Protocol.Player.gold)
  return _internal_gold();
}
inline void Player::_internal_set_gold(uint64_t value) {
  
  gold_ = value;
}
inline void Player::set_gold(uint64_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:Protocol.Player.gold)
}

// -------------------------------------------------------------------

// User

// repeated .Protocol.PlayerType playertype = 1;
inline int User::_internal_playertype_size() const {
  return playertype_.size();
}
inline int User::playertype_size() const {
  return _internal_playertype_size();
}
inline void User::clear_playertype() {
  playertype_.Clear();
}
inline ::Protocol::PlayerType User::_internal_playertype(int index) const {
  return static_cast< ::Protocol::PlayerType >(playertype_.Get(index));
}
inline ::Protocol::PlayerType User::playertype(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.User.playertype)
  return _internal_playertype(index);
}
inline void User::set_playertype(int index, ::Protocol::PlayerType value) {
  playertype_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.User.playertype)
}
inline void User::_internal_add_playertype(::Protocol::PlayerType value) {
  playertype_.Add(value);
}
inline void User::add_playertype(::Protocol::PlayerType value) {
  _internal_add_playertype(value);
  // @@protoc_insertion_point(field_add:Protocol.User.playertype)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
User::playertype() const {
  // @@protoc_insertion_point(field_list:Protocol.User.playertype)
  return playertype_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
User::_internal_mutable_playertype() {
  return &playertype_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
User::mutable_playertype() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.User.playertype)
  return _internal_mutable_playertype();
}

// uint64 id = 2;
inline void User::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t User::_internal_id() const {
  return id_;
}
inline uint64_t User::id() const {
  // @@protoc_insertion_point(field_get:Protocol.User.id)
  return _internal_id();
}
inline void User::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void User::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.User.id)
}

// string name = 3;
inline void User::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& User::name() const {
  // @@protoc_insertion_point(field_get:Protocol.User.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.User.name)
}
inline std::string* User::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.User.name)
  return _s;
}
inline const std::string& User::_internal_name() const {
  return name_.Get();
}
inline void User::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.User.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void User::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.User.name)
}

// uint64 x = 4;
inline void User::clear_x() {
  x_ = uint64_t{0u};
}
inline uint64_t User::_internal_x() const {
  return x_;
}
inline uint64_t User::x() const {
  // @@protoc_insertion_point(field_get:Protocol.User.x)
  return _internal_x();
}
inline void User::_internal_set_x(uint64_t value) {
  
  x_ = value;
}
inline void User::set_x(uint64_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.User.x)
}

// uint64 y = 5;
inline void User::clear_y() {
  y_ = uint64_t{0u};
}
inline uint64_t User::_internal_y() const {
  return y_;
}
inline uint64_t User::y() const {
  // @@protoc_insertion_point(field_get:Protocol.User.y)
  return _internal_y();
}
inline void User::_internal_set_y(uint64_t value) {
  
  y_ = value;
}
inline void User::set_y(uint64_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.User.y)
}

// uint64 gold = 6;
inline void User::clear_gold() {
  gold_ = uint64_t{0u};
}
inline uint64_t User::_internal_gold() const {
  return gold_;
}
inline uint64_t User::gold() const {
  // @@protoc_insertion_point(field_get:Protocol.User.gold)
  return _internal_gold();
}
inline void User::_internal_set_gold(uint64_t value) {
  
  gold_ = value;
}
inline void User::set_gold(uint64_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:Protocol.User.gold)
}

// -------------------------------------------------------------------

// Stat

// uint64 level = 1;
inline void Stat::clear_level() {
  level_ = uint64_t{0u};
}
inline uint64_t Stat::_internal_level() const {
  return level_;
}
inline uint64_t Stat::level() const {
  // @@protoc_insertion_point(field_get:Protocol.Stat.level)
  return _internal_level();
}
inline void Stat::_internal_set_level(uint64_t value) {
  
  level_ = value;
}
inline void Stat::set_level(uint64_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Protocol.Stat.level)
}

// uint64 exp = 2;
inline void Stat::clear_exp() {
  exp_ = uint64_t{0u};
}
inline uint64_t Stat::_internal_exp() const {
  return exp_;
}
inline uint64_t Stat::exp() const {
  // @@protoc_insertion_point(field_get:Protocol.Stat.exp)
  return _internal_exp();
}
inline void Stat::_internal_set_exp(uint64_t value) {
  
  exp_ = value;
}
inline void Stat::set_exp(uint64_t value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:Protocol.Stat.exp)
}

// uint64 maxexp = 3;
inline void Stat::clear_maxexp() {
  maxexp_ = uint64_t{0u};
}
inline uint64_t Stat::_internal_maxexp() const {
  return maxexp_;
}
inline uint64_t Stat::maxexp() const {
  // @@protoc_insertion_point(field_get:Protocol.Stat.maxexp)
  return _internal_maxexp();
}
inline void Stat::_internal_set_maxexp(uint64_t value) {
  
  maxexp_ = value;
}
inline void Stat::set_maxexp(uint64_t value) {
  _internal_set_maxexp(value);
  // @@protoc_insertion_point(field_set:Protocol.Stat.maxexp)
}

// uint64 hp = 4;
inline void Stat::clear_hp() {
  hp_ = uint64_t{0u};
}
inline uint64_t Stat::_internal_hp() const {
  return hp_;
}
inline uint64_t Stat::hp() const {
  // @@protoc_insertion_point(field_get:Protocol.Stat.hp)
  return _internal_hp();
}
inline void Stat::_internal_set_hp(uint64_t value) {
  
  hp_ = value;
}
inline void Stat::set_hp(uint64_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:Protocol.Stat.hp)
}

// uint64 maxhp = 5;
inline void Stat::clear_maxhp() {
  maxhp_ = uint64_t{0u};
}
inline uint64_t Stat::_internal_maxhp() const {
  return maxhp_;
}
inline uint64_t Stat::maxhp() const {
  // @@protoc_insertion_point(field_get:Protocol.Stat.maxhp)
  return _internal_maxhp();
}
inline void Stat::_internal_set_maxhp(uint64_t value) {
  
  maxhp_ = value;
}
inline void Stat::set_maxhp(uint64_t value) {
  _internal_set_maxhp(value);
  // @@protoc_insertion_point(field_set:Protocol.Stat.maxhp)
}

// uint64 mp = 6;
inline void Stat::clear_mp() {
  mp_ = uint64_t{0u};
}
inline uint64_t Stat::_internal_mp() const {
  return mp_;
}
inline uint64_t Stat::mp() const {
  // @@protoc_insertion_point(field_get:Protocol.Stat.mp)
  return _internal_mp();
}
inline void Stat::_internal_set_mp(uint64_t value) {
  
  mp_ = value;
}
inline void Stat::set_mp(uint64_t value) {
  _internal_set_mp(value);
  // @@protoc_insertion_point(field_set:Protocol.Stat.mp)
}

// uint64 maxmp = 7;
inline void Stat::clear_maxmp() {
  maxmp_ = uint64_t{0u};
}
inline uint64_t Stat::_internal_maxmp() const {
  return maxmp_;
}
inline uint64_t Stat::maxmp() const {
  // @@protoc_insertion_point(field_get:Protocol.Stat.maxmp)
  return _internal_maxmp();
}
inline void Stat::_internal_set_maxmp(uint64_t value) {
  
  maxmp_ = value;
}
inline void Stat::set_maxmp(uint64_t value) {
  _internal_set_maxmp(value);
  // @@protoc_insertion_point(field_set:Protocol.Stat.maxmp)
}

// uint64 attackPower = 8;
inline void Stat::clear_attackpower() {
  attackpower_ = uint64_t{0u};
}
inline uint64_t Stat::_internal_attackpower() const {
  return attackpower_;
}
inline uint64_t Stat::attackpower() const {
  // @@protoc_insertion_point(field_get:Protocol.Stat.attackPower)
  return _internal_attackpower();
}
inline void Stat::_internal_set_attackpower(uint64_t value) {
  
  attackpower_ = value;
}
inline void Stat::set_attackpower(uint64_t value) {
  _internal_set_attackpower(value);
  // @@protoc_insertion_point(field_set:Protocol.Stat.attackPower)
}

// uint64 defensePower = 9;
inline void Stat::clear_defensepower() {
  defensepower_ = uint64_t{0u};
}
inline uint64_t Stat::_internal_defensepower() const {
  return defensepower_;
}
inline uint64_t Stat::defensepower() const {
  // @@protoc_insertion_point(field_get:Protocol.Stat.defensePower)
  return _internal_defensepower();
}
inline void Stat::_internal_set_defensepower(uint64_t value) {
  
  defensepower_ = value;
}
inline void Stat::set_defensepower(uint64_t value) {
  _internal_set_defensepower(value);
  // @@protoc_insertion_point(field_set:Protocol.Stat.defensePower)
}

// uint64 magicPower = 10;
inline void Stat::clear_magicpower() {
  magicpower_ = uint64_t{0u};
}
inline uint64_t Stat::_internal_magicpower() const {
  return magicpower_;
}
inline uint64_t Stat::magicpower() const {
  // @@protoc_insertion_point(field_get:Protocol.Stat.magicPower)
  return _internal_magicpower();
}
inline void Stat::_internal_set_magicpower(uint64_t value) {
  
  magicpower_ = value;
}
inline void Stat::set_magicpower(uint64_t value) {
  _internal_set_magicpower(value);
  // @@protoc_insertion_point(field_set:Protocol.Stat.magicPower)
}

// uint64 strenth = 11;
inline void Stat::clear_strenth() {
  strenth_ = uint64_t{0u};
}
inline uint64_t Stat::_internal_strenth() const {
  return strenth_;
}
inline uint64_t Stat::strenth() const {
  // @@protoc_insertion_point(field_get:Protocol.Stat.strenth)
  return _internal_strenth();
}
inline void Stat::_internal_set_strenth(uint64_t value) {
  
  strenth_ = value;
}
inline void Stat::set_strenth(uint64_t value) {
  _internal_set_strenth(value);
  // @@protoc_insertion_point(field_set:Protocol.Stat.strenth)
}

// -------------------------------------------------------------------

// InventorySlot

// uint64 item_id = 1;
inline void InventorySlot::clear_item_id() {
  item_id_ = uint64_t{0u};
}
inline uint64_t InventorySlot::_internal_item_id() const {
  return item_id_;
}
inline uint64_t InventorySlot::item_id() const {
  // @@protoc_insertion_point(field_get:Protocol.InventorySlot.item_id)
  return _internal_item_id();
}
inline void InventorySlot::_internal_set_item_id(uint64_t value) {
  
  item_id_ = value;
}
inline void InventorySlot::set_item_id(uint64_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:Protocol.InventorySlot.item_id)
}

// uint64 quantity = 2;
inline void InventorySlot::clear_quantity() {
  quantity_ = uint64_t{0u};
}
inline uint64_t InventorySlot::_internal_quantity() const {
  return quantity_;
}
inline uint64_t InventorySlot::quantity() const {
  // @@protoc_insertion_point(field_get:Protocol.InventorySlot.quantity)
  return _internal_quantity();
}
inline void InventorySlot::_internal_set_quantity(uint64_t value) {
  
  quantity_ = value;
}
inline void InventorySlot::set_quantity(uint64_t value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:Protocol.InventorySlot.quantity)
}

// .Protocol.InventoryTab tab_type = 3;
inline void InventorySlot::clear_tab_type() {
  tab_type_ = 0;
}
inline ::Protocol::InventoryTab InventorySlot::_internal_tab_type() const {
  return static_cast< ::Protocol::InventoryTab >(tab_type_);
}
inline ::Protocol::InventoryTab InventorySlot::tab_type() const {
  // @@protoc_insertion_point(field_get:Protocol.InventorySlot.tab_type)
  return _internal_tab_type();
}
inline void InventorySlot::_internal_set_tab_type(::Protocol::InventoryTab value) {
  
  tab_type_ = value;
}
inline void InventorySlot::set_tab_type(::Protocol::InventoryTab value) {
  _internal_set_tab_type(value);
  // @@protoc_insertion_point(field_set:Protocol.InventorySlot.tab_type)
}

// uint64 inv_slot_index = 4;
inline void InventorySlot::clear_inv_slot_index() {
  inv_slot_index_ = uint64_t{0u};
}
inline uint64_t InventorySlot::_internal_inv_slot_index() const {
  return inv_slot_index_;
}
inline uint64_t InventorySlot::inv_slot_index() const {
  // @@protoc_insertion_point(field_get:Protocol.InventorySlot.inv_slot_index)
  return _internal_inv_slot_index();
}
inline void InventorySlot::_internal_set_inv_slot_index(uint64_t value) {
  
  inv_slot_index_ = value;
}
inline void InventorySlot::set_inv_slot_index(uint64_t value) {
  _internal_set_inv_slot_index(value);
  // @@protoc_insertion_point(field_set:Protocol.InventorySlot.inv_slot_index)
}

// -------------------------------------------------------------------

// EquipmentItem

// .Protocol.EquipmentSlot eq_slot = 1;
inline void EquipmentItem::clear_eq_slot() {
  eq_slot_ = 0;
}
inline ::Protocol::EquipmentSlot EquipmentItem::_internal_eq_slot() const {
  return static_cast< ::Protocol::EquipmentSlot >(eq_slot_);
}
inline ::Protocol::EquipmentSlot EquipmentItem::eq_slot() const {
  // @@protoc_insertion_point(field_get:Protocol.EquipmentItem.eq_slot)
  return _internal_eq_slot();
}
inline void EquipmentItem::_internal_set_eq_slot(::Protocol::EquipmentSlot value) {
  
  eq_slot_ = value;
}
inline void EquipmentItem::set_eq_slot(::Protocol::EquipmentSlot value) {
  _internal_set_eq_slot(value);
  // @@protoc_insertion_point(field_set:Protocol.EquipmentItem.eq_slot)
}

// uint64 item_id = 2;
inline void EquipmentItem::clear_item_id() {
  item_id_ = uint64_t{0u};
}
inline uint64_t EquipmentItem::_internal_item_id() const {
  return item_id_;
}
inline uint64_t EquipmentItem::item_id() const {
  // @@protoc_insertion_point(field_get:Protocol.EquipmentItem.item_id)
  return _internal_item_id();
}
inline void EquipmentItem::_internal_set_item_id(uint64_t value) {
  
  item_id_ = value;
}
inline void EquipmentItem::set_item_id(uint64_t value) {
  _internal_set_item_id(value);
  // @@protoc_insertion_point(field_set:Protocol.EquipmentItem.item_id)
}

// -------------------------------------------------------------------

// AddPlayer

// repeated .Protocol.PlayerType playertype = 1;
inline int AddPlayer::_internal_playertype_size() const {
  return playertype_.size();
}
inline int AddPlayer::playertype_size() const {
  return _internal_playertype_size();
}
inline void AddPlayer::clear_playertype() {
  playertype_.Clear();
}
inline ::Protocol::PlayerType AddPlayer::_internal_playertype(int index) const {
  return static_cast< ::Protocol::PlayerType >(playertype_.Get(index));
}
inline ::Protocol::PlayerType AddPlayer::playertype(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.AddPlayer.playertype)
  return _internal_playertype(index);
}
inline void AddPlayer::set_playertype(int index, ::Protocol::PlayerType value) {
  playertype_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.AddPlayer.playertype)
}
inline void AddPlayer::_internal_add_playertype(::Protocol::PlayerType value) {
  playertype_.Add(value);
}
inline void AddPlayer::add_playertype(::Protocol::PlayerType value) {
  _internal_add_playertype(value);
  // @@protoc_insertion_point(field_add:Protocol.AddPlayer.playertype)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
AddPlayer::playertype() const {
  // @@protoc_insertion_point(field_list:Protocol.AddPlayer.playertype)
  return playertype_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
AddPlayer::_internal_mutable_playertype() {
  return &playertype_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
AddPlayer::mutable_playertype() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.AddPlayer.playertype)
  return _internal_mutable_playertype();
}

// uint64 id = 2;
inline void AddPlayer::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t AddPlayer::_internal_id() const {
  return id_;
}
inline uint64_t AddPlayer::id() const {
  // @@protoc_insertion_point(field_get:Protocol.AddPlayer.id)
  return _internal_id();
}
inline void AddPlayer::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void AddPlayer::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.AddPlayer.id)
}

// string name = 3;
inline void AddPlayer::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& AddPlayer::name() const {
  // @@protoc_insertion_point(field_get:Protocol.AddPlayer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddPlayer::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.AddPlayer.name)
}
inline std::string* AddPlayer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.AddPlayer.name)
  return _s;
}
inline const std::string& AddPlayer::_internal_name() const {
  return name_.Get();
}
inline void AddPlayer::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AddPlayer::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AddPlayer::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.AddPlayer.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AddPlayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.AddPlayer.name)
}

// uint64 x = 4;
inline void AddPlayer::clear_x() {
  x_ = uint64_t{0u};
}
inline uint64_t AddPlayer::_internal_x() const {
  return x_;
}
inline uint64_t AddPlayer::x() const {
  // @@protoc_insertion_point(field_get:Protocol.AddPlayer.x)
  return _internal_x();
}
inline void AddPlayer::_internal_set_x(uint64_t value) {
  
  x_ = value;
}
inline void AddPlayer::set_x(uint64_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.AddPlayer.x)
}

// uint64 y = 5;
inline void AddPlayer::clear_y() {
  y_ = uint64_t{0u};
}
inline uint64_t AddPlayer::_internal_y() const {
  return y_;
}
inline uint64_t AddPlayer::y() const {
  // @@protoc_insertion_point(field_get:Protocol.AddPlayer.y)
  return _internal_y();
}
inline void AddPlayer::_internal_set_y(uint64_t value) {
  
  y_ = value;
}
inline void AddPlayer::set_y(uint64_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.AddPlayer.y)
}

// -------------------------------------------------------------------

// Move

// uint64 id = 1;
inline void Move::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t Move::_internal_id() const {
  return id_;
}
inline uint64_t Move::id() const {
  // @@protoc_insertion_point(field_get:Protocol.Move.id)
  return _internal_id();
}
inline void Move::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void Move::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.Move.id)
}

// uint64 x = 2;
inline void Move::clear_x() {
  x_ = uint64_t{0u};
}
inline uint64_t Move::_internal_x() const {
  return x_;
}
inline uint64_t Move::x() const {
  // @@protoc_insertion_point(field_get:Protocol.Move.x)
  return _internal_x();
}
inline void Move::_internal_set_x(uint64_t value) {
  
  x_ = value;
}
inline void Move::set_x(uint64_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Protocol.Move.x)
}

// uint64 y = 3;
inline void Move::clear_y() {
  y_ = uint64_t{0u};
}
inline uint64_t Move::_internal_y() const {
  return y_;
}
inline uint64_t Move::y() const {
  // @@protoc_insertion_point(field_get:Protocol.Move.y)
  return _internal_y();
}
inline void Move::_internal_set_y(uint64_t value) {
  
  y_ = value;
}
inline void Move::set_y(uint64_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Protocol.Move.y)
}

// int64 move_time = 4;
inline void Move::clear_move_time() {
  move_time_ = int64_t{0};
}
inline int64_t Move::_internal_move_time() const {
  return move_time_;
}
inline int64_t Move::move_time() const {
  // @@protoc_insertion_point(field_get:Protocol.Move.move_time)
  return _internal_move_time();
}
inline void Move::_internal_set_move_time(int64_t value) {
  
  move_time_ = value;
}
inline void Move::set_move_time(int64_t value) {
  _internal_set_move_time(value);
  // @@protoc_insertion_point(field_set:Protocol.Move.move_time)
}

// -------------------------------------------------------------------

// Mess

// uint64 id = 1;
inline void Mess::clear_id() {
  id_ = uint64_t{0u};
}
inline uint64_t Mess::_internal_id() const {
  return id_;
}
inline uint64_t Mess::id() const {
  // @@protoc_insertion_point(field_get:Protocol.Mess.id)
  return _internal_id();
}
inline void Mess::_internal_set_id(uint64_t value) {
  
  id_ = value;
}
inline void Mess::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.Mess.id)
}

// string mess = 2;
inline void Mess::clear_mess() {
  mess_.ClearToEmpty();
}
inline const std::string& Mess::mess() const {
  // @@protoc_insertion_point(field_get:Protocol.Mess.mess)
  return _internal_mess();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Mess::set_mess(ArgT0&& arg0, ArgT... args) {
 
 mess_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.Mess.mess)
}
inline std::string* Mess::mutable_mess() {
  std::string* _s = _internal_mutable_mess();
  // @@protoc_insertion_point(field_mutable:Protocol.Mess.mess)
  return _s;
}
inline const std::string& Mess::_internal_mess() const {
  return mess_.Get();
}
inline void Mess::_internal_set_mess(const std::string& value) {
  
  mess_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Mess::_internal_mutable_mess() {
  
  return mess_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Mess::release_mess() {
  // @@protoc_insertion_point(field_release:Protocol.Mess.mess)
  return mess_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Mess::set_allocated_mess(std::string* mess) {
  if (mess != nullptr) {
    
  } else {
    
  }
  mess_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mess,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mess_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mess_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.Mess.mess)
}

// -------------------------------------------------------------------

// GoldRanking

// string name = 1;
inline void GoldRanking::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& GoldRanking::name() const {
  // @@protoc_insertion_point(field_get:Protocol.GoldRanking.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GoldRanking::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.GoldRanking.name)
}
inline std::string* GoldRanking::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.GoldRanking.name)
  return _s;
}
inline const std::string& GoldRanking::_internal_name() const {
  return name_.Get();
}
inline void GoldRanking::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GoldRanking::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GoldRanking::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.GoldRanking.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GoldRanking::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.GoldRanking.name)
}

// uint64 gold = 2;
inline void GoldRanking::clear_gold() {
  gold_ = uint64_t{0u};
}
inline uint64_t GoldRanking::_internal_gold() const {
  return gold_;
}
inline uint64_t GoldRanking::gold() const {
  // @@protoc_insertion_point(field_get:Protocol.GoldRanking.gold)
  return _internal_gold();
}
inline void GoldRanking::_internal_set_gold(uint64_t value) {
  
  gold_ = value;
}
inline void GoldRanking::set_gold(uint64_t value) {
  _internal_set_gold(value);
  // @@protoc_insertion_point(field_set:Protocol.GoldRanking.gold)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Struct_2eproto
